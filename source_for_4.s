	.intel_syntax noprefix                   # показывает, что синтаксис intel
	.text                                    # начало секции
	.comm	cstring,4000000,32               # массив cstring элементов char
	.comm	amount,20,16                     # массив amount элементов int
	.section	.rodata                      # секция .rodata
.LC0:                                        # метка .LC0
	.string	"input string is too big!"       # строка, сообщение о том что введенная строка слишком большая
.LC1:                                        # метка .LC1
	.string	"'.': %d\n"                      # строка, используемая для указания формата вывода количества точек
.LC2:                                        # метка .LC2
	.string	"',': %d\n"                      # строка, используемая для указания формата вывода количества запятых
.LC3:                                        # метка .LC3
	.string	"'!': %d\n"                      # строка, используемая для указания формата вывода количества восклицательных знаков
.LC4:                                        # метка .LC4
	.string	"'?': %d\n"                      # строка, используемая для указания формата вывода количества вопросительных знаков
.LC5:                                        # метка .LC5
	.string	"';': %d\n"                      # строка, используемая для указания формата вывода количества точек с запятой
	.text                                    # секция с кодом
	.globl	main                             # объявлюю символ main
	.type	main, @function                  # указание, что main это функция
main:                                        # метка main
	push	rbp                              # сохраняю rbp на стеке
	mov	rbp, rsp                             # присваиваю регистру rbp значение из rsp
	sub	rsp, 32                              # сдвигаю регистр rsp на 32 (вычитаю 32)
	mov	DWORD PTR -20[rbp], edi              # аргумент argc кладется в edi
	mov	QWORD PTR -32[rbp], rsi              # аргумент argv кладется в rsi
	mov	DWORD PTR -8[rbp], 0                 # присваиваю rbp[-8] значение 0 (rbp[-8] это аналог переменной i)
	mov	DWORD PTR -4[rbp], 0                 # присваиваю rbp[-4] значение 0 (rbp[-4] это аналог переменной size)
	jmp	.L2                                  # переход на метку .L2
.L3:                                         # метка .L3
	mov	eax, DWORD PTR -4[rbp]               # присваиваю регистру eax значение rbp[-4] (rbp[-4] это аналог переменной i)
	cdqe                                     # расширение 32 битного значения в eax до 64 битного в rax
	lea	rdx, 0[0+rax*4]                      # присваиваю регистру rdx значение rax * 4
	lea	rax, amount[rip]                     # присваиваю регистру rax значение &amount[rip] (адрес начала массива amount)
	mov	DWORD PTR [rdx+rax], 0               # присваиваю по ссылке *(rdx+rax) значение 0
	add	DWORD PTR -4[rbp], 1                 # увеличиваю значение переменной rbp[-4] на 1 (rbp[-4] это аналог переменной i)
.L2:                                         # метка .L2
	cmp	DWORD PTR -4[rbp], 4                 # сравниваю значение rbp[-4] и 4 (rbp[-4] это аналог переменной i)
	jle	.L3                                  # в случае, если результат сравнения <=, то перехожу на метку .L3
.L5:                                         # метка .L5
	mov	rax, QWORD PTR stdin[rip]            # присваиваю регистру rax значение &stdin[rip] (ссылка на поток stdin)
	mov	rdi, rax                             # присваиваю регистру rdi значение регистра rax
	call	fgetc@PLT                        # вызываю макрос fgetc
	mov	BYTE PTR -9[rbp], al                 # присваиваю rbp[-9] значение регистра al (rbp[-9] это аналог переменной symbol)
	mov	eax, DWORD PTR -8[rbp]               # присваиваю регистру eax значение rbp[-8]
	lea	edx, 1[rax]                          # присваиваю регистру edx значение по ссылке rax + 1
	mov	DWORD PTR -8[rbp], edx               # присваиваю rbp[-8] значение регистра edx (rbp[-8] это аналог переменной i)
	cdqe                                     # расширение 32 битного значения в eax до 64 битного в rax
	lea	rcx, cstring[rip]                    # присваиваю регистру rcx значение &cstring[rip] (адрес начала массива cstring)
	movzx	edx, BYTE PTR -9[rbp]            # присваивает регистру edx значение rbp[-9] с расширением нулями (rbp[-9] это аналог переменной symbol)
	mov	BYTE PTR [rax+rcx], dl               # присваиваю по ссылке *(rax + rcx) значение регистра dl
	cmp	BYTE PTR -9[rbp], -1                 # сравниваю значение rbp[-9] и -1 (rbp[-9] это аналог переменной symbol)
	je	.L4                                  # в случае, если рещультат предыдущего сравнения =, то перехожу на метку .L4
	cmp	DWORD PTR -8[rbp], 3999999           # сравниваю значение rbp[-8] и 3999999 (rbp[-8] это аналог переменной i)
	jle	.L5                                  # в случае, если результат предыдущего сравнения <, то перехожу на метку .L5
.L4:                                         # метка .L4
	cmp	BYTE PTR -9[rbp], -1                 # сравниваю значение rbp[-9] и -1
	je	.L6                                  # в случае, если результат предыдущего сравнения <, то перехожу на метку .L6
	cmp	DWORD PTR -8[rbp], 3999999           # сравниваю значение rbp[-8] и 3999999 (rbp[-8] это аналог переменной i)
	jle	.L6                                  # в случае, если результат предыдущего сравнения <=, то перехожу на метку .L6
	lea	rdi, .LC0[rip]                       # присваиваю регистру rdi значение &.LC0[rip] (ссылка на строку с сообщением о том, что строка слишком длинная)
	mov	eax, 0                               # присваиваю регистру eax значение 0
	call	printf@PLT                       # вызываю макрос printf
	mov	eax, 0                               # присваиваю регистру eax значение 0
	jmp	.L7                                  # перехожу на метку .L7
.L6:                                         # метка .L6
	mov	eax, DWORD PTR -8[rbp]               # присваиваю регистру eax значение rbp[-8] (rbp[-8] это аналог переменной i)
	sub	eax, 1                               # увеличиваю значение регистра eax на 1
	cdqe                                     # расширение 32 битного значения в eax до 64 битного в rax
	lea	rdx, cstring[rip]                    # присваиваю регистру rdx значение &cstring[rip] (адрес начала массива cstring)
	mov	BYTE PTR [rax+rdx], 0                # присваиваю по ссылке *(rax + rdx) значение 0
	mov	DWORD PTR -4[rbp], 0                 # присваиваю регистру rbp[-4] значение 0 (rbp[-4] это аналог переменной size)
	jmp	.L8                                  # перехожу на метку .L8
.L14:                                        # метка .L14
	mov	eax, DWORD PTR -4[rbp]               # присваиваю регистру eax значение rbp[-4] (rbp[-4] это аналог переменной size)
	cdqe                                     # расширение 32 битного значения в eax до 64 битного в rax
	lea	rdx, cstring[rip]                    # присваиваю регистру rdx значение &cstring[rip] с расширением (ссылка на начало массива cstring)
	movzx	eax, BYTE PTR [rax+rdx]          # присваиваю регистру eax значение по ссылке (rax+rdx)
	cmp	al, 46                               # сравниваю значение регистра al и 46
	jne	.L9                                  # в случае, если результат предыдущего сравнения !=, то перехожу на метку .L9
	mov	eax, DWORD PTR amount[rip]           # присваиваю регистру eax значение &amount[rip] (ссылка на начало массива amount)
	add	eax, 1                               # увеличиваю значение регистра eax на 1
	mov	DWORD PTR amount[rip], eax           # присваиваю по ссылке amount[rip] значение регистра eax
.L9:                                         # метка .L9
	mov	eax, DWORD PTR -4[rbp]               # присваиваю регистру eax значение rbp[-4] (rbp[-4] это аналог переменной size)
	cdqe                                     # расширение 32 битного значения в eax до 64 битного в rax
	lea	rdx, cstring[rip]                    # присваиваю регистру rdx значение &cstring[rip] (ссылка на начало массива cstring)
	movzx	eax, BYTE PTR [rax+rdx]          # присваиваю регистру eax значение по ссылке *(rax + rdx) с расширением нулями
	cmp	al, 44                               # сравниваю значение регистра al и 44
	jne	.L10                                 # в случае, если результат предыдущего сравнения !=, то перехожу на метку .L10
	mov	eax, DWORD PTR amount[rip+4]         # присваиваю регистру eax значение amount[rip + 4] (элемент массива с индексом 1)
	add	eax, 1                               # увеличиваю значение регистра eax на 1
	mov	DWORD PTR amount[rip+4], eax         # присваиваю по ссылке amount[rip + 4] значение eax
.L10:                                        # метка .L10
	mov	eax, DWORD PTR -4[rbp]               # присваиваю регистру eax значение rbp[-4] (это аналог переменной size)
	cdqe                                     # расширение 32 битного значения в eax до 64 битного в rax
	lea	rdx, cstring[rip]                    # присваиваю регистру rdx значение &cstring[rip] (ссылка на начало массива cstring)
	movzx	eax, BYTE PTR [rax+rdx]          # присваиваю регистру eax значение по ссылке *(rax + rdx) с расширением нулями
	cmp	al, 33                               # сравниваю значение регистра al и 33
	jne	.L11                                 # в случае, если результат предыдущего сравнения !=, то перехожу на метку .L11
	mov	eax, DWORD PTR amount[rip+8]         # присваиваю регистру eax значение amount[rip + 8] (элемент массива с индексом 2)
	add	eax, 1                               # увеличиваю значение регистра eax на 1
	mov	DWORD PTR amount[rip+8], eax         # присваиваю по amount[rip + 8] значение регистра eax
.L11:                                        # метка .L11
	mov	eax, DWORD PTR -4[rbp]               # присваиваю регистру eax значение rbp[-4] (rbp[-4] это аналог переменной size)
	cdqe                                     # расширение 32 битного значения в eax до 64 битного в rax
	lea	rdx, cstring[rip]                    # присваиваю регистру rdx значение &cstring[rip] (ссылка на начало массива cstring)
	movzx	eax, BYTE PTR [rax+rdx]          # присваиваю регистру eax значение по ссылке *(rax + rdx) с расширением нулями
	cmp	al, 63                               # сравниваю значение регистра al и 63
	jne	.L12                                 # в случае, если результат предыдущего сравнения !=, то перехожу на метку .L12
	mov	eax, DWORD PTR amount[rip+12]        # присваиваю регистру eax значение amount[rip + 12] (элемент массива с индексом 3)
	add	eax, 1                               # увеличиваю значение регистра eax на 1
	mov	DWORD PTR amount[rip+12], eax        # присваиваю зпо ссылке amount[rip + 12] значение регистра eax
.L12:                                        # метка .L12
	mov	eax, DWORD PTR -4[rbp]               # присваиваю регистру eax значение rbp[-4] (rbp[-4] это аналог переменной size)
	cdqe                                     # расширение 32 битного значения в eax до 64 битного в rax
	lea	rdx, cstring[rip]                    # присваиваю регистру rdx значение &cstring[rip] (ссылка на начало массива cstring)
	movzx	eax, BYTE PTR [rax+rdx]          # присваиваю регистру eax значение по ссылке *(rax + rdx) с расширением нулями
	cmp	al, 59                               # сравниваю значение регистра al и 59
	jne	.L13                                 # в случае, если результат предыдущего сравнения !=, перехожу на метку .L13
	mov	eax, DWORD PTR amount[rip+16]        # присваиваю регистру eax значение по ссылке amount[rip + 16] (элемент массива с индексом 4)
	add	eax, 1                               # увеличиваю значение регистра eax на 1
	mov	DWORD PTR amount[rip+16], eax        # присваиваю по ссылке amount[rip + 16] значение регистра eax
.L13:                                        # метка .L13
	add	DWORD PTR -4[rbp], 1                 # увеличиваю значение rbp[-4] на 1 (rbp[-4] это аналог переменной size)
.L8:                                         # метка .L8
	mov	eax, DWORD PTR -4[rbp]               # присваиваю регистру eax значение rbp[-4] (rbp[-4] это аналог переменной size)
	cmp	eax, DWORD PTR -8[rbp]               # сравниваю значение регистра eax и rbp[-8] (rbp[-8] это аналог переменной i)
	jl	.L14                                 # в случае, если результат предыдущего сравнения <, то перехожу на метку .L14
	mov	eax, DWORD PTR amount[rip]           # присваиваю регистру eax значение amount[rip] (ссылка на элемент массива с индексом 0)
	mov	esi, eax                             # присваиваю регистру esi значение регистра eax
	lea	rdi, .LC1[rip]                       # присваиваю регистру rdi значение .LC1[rip] (строка для формата вывода количества точек в строке)
	mov	eax, 0                               # присваиваю регистру eax значение 0
	call	printf@PLT                       # вызываю макрос printf
	mov	eax, DWORD PTR amount[rip+4]         # присваиваю регистру eax значение amount[rip + 4] (элемент массива с индексом 1)
	mov	esi, eax                             # присваиваю регистру esi значение регистра eax
	lea	rdi, .LC2[rip]                       # присваиваю регистру rdi значение .LC2[rip] (строка для формата вывода количества запятых в строке)
	mov	eax, 0                               # присваиваю регистру eax значение 0
	call	printf@PLT                       # вызываю макрос printf
	mov	eax, DWORD PTR amount[rip+8]         # присваиваю регистру eax значение amount[rip + 8] (элемент массива с индексом 2)
	mov	esi, eax                             # присваиваю регистру esi значение регистра eax
	lea	rdi, .LC3[rip]                       # присваиваю регистру rdi значение .LC3[rip] (строка для формата вывода количества восклицательных знаков в строке)
	mov	eax, 0                               # присваиваю регистру eax значение 0
	call	printf@PLT                       # вызываю макрос printf
	mov	eax, DWORD PTR amount[rip+12]        # присваиваю регистру eax значение amount[rip + 12] (элемент массива с индексом 3)
	mov	esi, eax                             # присваиваю регистру esi значение регистра eax
	lea	rdi, .LC4[rip]                       # присваиваю регистру rdi значение .LC4[rip] (строка для формата вывода количества вопросительных знаков в строке)
	mov	eax, 0                               # присваиваю регистру eax значение 0
	call	printf@PLT                       # вызываю макрос printf
	mov	eax, DWORD PTR amount[rip+16]        # присваиваю регистру eax значение amount[rip + 16] (элемент массива с индексом 4)
	mov	esi, eax                             # присваиваю регистру esi значение регистра eax
	lea	rdi, .LC5[rip]                       # присваиваю регистру rdi значение .LC5[rip] (строка для формата вывода количества точек с запятой в строке)
	mov	eax, 0                               # присваиваю регистру eax значение 0
	call	printf@PLT                       # вызываю макрос printf
	mov	eax, 0                               # присваиваю регистру eax значение 0
.L7:                                         # метка .L7
	leave                                    # выход из функции
	ret                                      # выход из функции
